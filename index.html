<script>
    // ===== Storage Keys =====
    const BM_KEY = "auraX_bm_v1";
    const RECYCLE_KEY = "auraX_recycle_48h_v1";

    // ===== Global State =====
    let bmStore = loadJson(BM_KEY, []);
    let recycleStore = loadJson(RECYCLE_KEY, []);
    let E0 = 0.0;
    let lastMatch = null;
    let voiceOn = false;

    // ===== Utility =====
    function loadJson(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return fallback;
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : fallback;
      } catch (e) {
        return fallback;
      }
    }
    function saveJson(key, value) {
      try { localStorage.setItem(key, JSON.stringify(value)); } catch (e) {}
    }
    function nowIso() {
      return new Date().toISOString();
    }
    function shortDateTime(iso) {
      const d = new Date(iso);
      return d.toLocaleDateString() + " " + d.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
    }

    // ===== Seed BM (Crow story example) =====
    if (bmStore.length === 0) {
      bmStore.push({
        id: "seed-thirsty-crow",
        title: "Thirsty Crow",
        createdAt: nowIso(),
        kind: "story",
        text: `
A scorching summer day had arrived, making the land dry and hot.
A clever black crow felt terribly thirsty and searched for water.
He finally saw a pitcher, but the water level inside was very low.
His beak could not reach the water and he felt disappointed.
He refused to give up, looked around, and noticed many small stones.
He dropped the stones into the pitcher one by one.
The water slowly rose until he could drink.
The crow happily took a long drink ‚Äì necessity is the mother of invention.`,
      });
      saveJson(BM_KEY, bmStore);
    }

    // ===== Chat Rendering =====
    const chatLog = document.getElementById("chatLog");
    function addMessage(author, label, text) {
      const div = document.createElement("div");
      div.className = "msg";
      const meta = document.createElement("div");
      meta.className = "msg-meta";
      const left = document.createElement("div");
      left.innerHTML = `<span class="msg-author">${author}</span>`;
      const right = document.createElement("div");
      right.innerHTML = `<span class="msg-label">${label}</span>`;
      meta.appendChild(left);
      meta.appendChild(right);
      const body = document.createElement("div");
      body.className = author === "User" ? "msg-body-user" : "msg-body-bot";
      body.textContent = text;
      div.appendChild(meta);
      div.appendChild(body);
      chatLog.appendChild(div);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    // ===== TM / BM Logic =====
    const stopwords = new Set([
      "the","is","am","are","a","an","and","or","of","to","in","on","for",
      "with","at","by","it","this","that","was","were","be","as","from","up",
      "down","very","so","but","then","had","have","has","his","her","their"
    ]);

    function tokenize(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, " ")
        .split(/\s+/)
        .filter(w => w.length > 2 && !stopwords.has(w));
    }

    function toBigrams(tokens) {
      const bigrams = [];
      for (let i = 0; i < tokens.length - 1; i++) {
        bigrams.push(tokens[i] + " " + tokens[i+1]);
      }
      return bigrams;
    }

    // Rough emotional keywords map ‚Üí simple emotional sequence
    const emotionLex = [
      { key: ["hope","hopeful","idea","plan","solution","clever"], tag: "hope" },
      { key: ["thirsty","need","hungry"], tag: "need" },
      { key: ["disappoint","sad","upset","unhappy"], tag: "disappointment" },
      { key: ["angry","anger","mad","furious"], tag: "anger" },
      { key: ["afraid","fear","scared"], tag: "fear" },
      { key: ["try","effort","work","struggle","stones","pebbles"], tag: "effort" },
      { key: ["happy","joy","satisfying","relief","relieved"], tag: "joy" }
    ];

    function extractEmotionSeq(text) {
      const tokens = tokenize(text);
      const seq = [];
      for (const t of tokens) {
        for (const rule of emotionLex) {
          if (rule.key.some(k => t.startsWith(k))) {
            if (seq[seq.length - 1] !== rule.tag) {
              seq.push(rule.tag);
            }
            break;
          }
        }
      }
      return seq;
    }

    function emotionMatch(seqA, seqB) {
      const len = Math.min(seqA.length, seqB.length);
      if (len < 3) return 0; // must have at least 3 aligned stages
      let matches = 0;
      for (let i = 0; i < len; i++) {
        if (seqA[i] === seqB[i]) matches++;
      }
      return matches / len;
    }

    function jaccardOverlap(a, b) {
      const setA = new Set(a);
      const setB = new Set(b);
      let inter = 0;
      for (const x of setA) if (setB.has(x)) inter++;
      const minSize = Math.min(setA.size, setB.size);
      if (minSize === 0) return 0;
      return inter / minSize;
    }

    function computeMatch(tmText) {
      const tmTokens = tokenize(tmText);

      // üîí TM must be "big enough": at least 10 meaningful words
      if (tmTokens.length < 10) return null;

      const tmBigrams = toBigrams(tmTokens);
      const tmEmotions = extractEmotionSeq(tmText);

      let best = null;

      for (const mem of bmStore) {
        if (mem.kind === "small-talk") continue; // safety
        const memTokens = tokenize(mem.text || "");
        // üîí BM memory must also be fairly big
        if (memTokens.length < 10) continue;

        const memBigrams = toBigrams(memTokens);
        const memEmotions = extractEmotionSeq(mem.text || "");

        const wordScore = jaccardOverlap(tmTokens, memTokens);
        const patternScore = jaccardOverlap(tmBigrams, memBigrams);
        const emotionScore = emotionMatch(tmEmotions, memEmotions);

        const total = 0.5 * wordScore + 0.2 * patternScore + 0.3 * emotionScore;

        if (!best || total > best.score) {
          best = {
            score: total,
            wordScore,
            patternScore,
            emotionScore,
            memory: mem
          };
        }
      }

      // Dead-zone: below 0.40 = ‚Äúno recall‚Äù
      if (!best || best.score < 0.40) return null;
      return best;
    }

    // ===== E0 + Reaction =====
    const polarityDisplay = document.getElementById("polarityDisplay");
    const toneDisplay = document.getElementById("toneDisplay");
    const reactionText = document.getElementById("reactionText");

    function updateReaction(tmText) {
      const tokens = tokenize(tmText);
      let pos = 0, neg = 0;
      const posWords = ["happy","hope","kind","love","joy","calm","peace","clever"];
      const negWords = ["sad","angry","upset","hate","fear","worried","tired","lonely","thirsty","disappoint","frustrated"];

      for (const t of tokens) {
        if (posWords.some(w => t.startsWith(w))) pos++;
        if (negWords.some(w => t.startsWith(w))) neg++;
      }
      const total = pos + neg || 1;
      const posRatio = pos / total;
      const negRatio = neg / total;
      E0 = Math.tanh(posRatio - negRatio);

      const posPct = Math.round((posRatio) * 100);
      const negPct = 100 - posPct;

      polarityDisplay.textContent = `Polarity: ${E0 >= 0 ? "Positive" : "Negative"} ¬∑ ${posPct} : ${negPct}`;

      let tone;
      if (Math.abs(E0) < 0.2) {
        tone = "Light, gentle, low-amplitude positive drift.";
      } else if (E0 > 0.5) {
        tone = "Soft, stabilizing, hopeful resonance.";
      } else if (E0 < -0.5) {
        tone = "Heavy, contracting, high-amplitude negative stress.";
      } else {
        tone = "Balanced but emotionally significant drift.";
      }
      toneDisplay.textContent = `Tone: ${tone}`;

      const line = `I've received your TM event and collided it with the current BM state. E‚ÇÄ is now around ${E0.toFixed(2)} (range ‚àí1 to +1). The more clearly you describe context, the stronger and cleaner your BM trace becomes.`;
      reactionText.textContent = line;
    }

    // ===== Match Banner + Auto-Recall Modal =====
    const matchBanner = document.getElementById("matchBanner");
    const matchText = document.getElementById("matchText");
    const openMatchBtn = document.getElementById("openMatchBtn");

    function hideMatchBanner() {
      matchBanner.style.display = "none";
      lastMatch = null;
    }

    function showMatchBanner(match) {
      lastMatch = match;
      const pct = Math.round(match.score * 100);
      matchText.textContent = `Related memory ~${pct}% match. Open previous topic?`;
      matchBanner.style.display = "flex";

      if (pct >= 70) {
        openRecallModal(match);
      }
    }

    function openRecallModal(match) {
      const modal = document.getElementById("recallModal");
      const body = document.getElementById("recallModalBody");
      const pct = Math.round(match.score * 100);
      const day = new Date().toISOString().slice(0,10);

      const polarityText = E0 >= 0 ? "Positive" : "Negative";
      const posPct = E0 >= 0 ? Math.round((E0 + 1)/2 * 100) : Math.round((1 - (E0+1)/2) * 100);
      const negPct = 100 - posPct;

      body.textContent =
`Day: ${day} ¬∑ Match ‚âà ${pct}%

Polarity: ${polarityText} ¬∑ E‚ÇÄ‚âà${E0.toFixed(2)}
Polarity split: ${posPct} : ${negPct}

Title: ${match.memory.title || "Untitled memory"}

${match.memory.text.trim()}`;

      modal.style.display = "flex";
    }

    function closeModal(id) {
      const el = document.getElementById(id);
      if (el) el.style.display = "none";
    }

    document.querySelectorAll(".modal-close").forEach(btn => {
      btn.addEventListener("click", e => {
        const id = btn.getAttribute("data-close");
        if (id) closeModal(id);
      });
    });

    openMatchBtn.addEventListener("click", () => {
      if (!lastMatch) return;
      openRecallModal(lastMatch);
    });

    // ===== Small Talk Detection & Recycle =====
    function isGreeting(text) {
      const t = text.toLowerCase().trim();
      return (
        t === "hi" || t === "hello" || t === "hey" ||
        t.startsWith("how are you") ||
        t.startsWith("salam") || t.startsWith("assalam")
      );
    }

    function isSmallTalk(text) {
      if (isGreeting(text)) return true;
      if (text.length < 80) return true;   // chhota message = chitchat
      return false;
    }

    function pushRecycle(userText, botText) {
      const entry = {
        id: "r-" + Date.now(),
        at: nowIso(),
        user: userText,
        bot: botText
      };
      recycleStore.push(entry);
      const cutoff = Date.now() - (48 * 60 * 60 * 1000);
      recycleStore = recycleStore.filter(e => new Date(e.at).getTime() >= cutoff);
      saveJson(RECYCLE_KEY, recycleStore);
    }

    // ===== BM Save =====
    function saveBMEvent(userText, botText) {
      const entry = {
        id: "bm-" + Date.now(),
        title: summarizeTitle(userText),
        createdAt: nowIso(),
        kind: "story",
        text: botText ? (userText + "\n\n" + botText) : userText
      };
      bmStore.push(entry);
      if (bmStore.length > 200) bmStore.shift();
      saveJson(BM_KEY, bmStore);
    }

    function summarizeTitle(text) {
      const tokens = tokenize(text);
      if (tokens.length === 0) return "Memory";
      return tokens.slice(0,4).map(w => w[0].toUpperCase()+w.slice(1)).join(" ");
    }

    // ===== BM Viewer =====
    const bmModalBody = document.getElementById("bmModalBody");
    document.getElementById("btnBmViewer").addEventListener("click", () => {
      if (bmStore.length === 0) {
        bmModalBody.textContent = "No BM entries yet.";
      } else {
        bmModalBody.textContent = bmStore
          .slice()
          .reverse()
          .map(m => `‚Ä¢ ${m.title || "Untitled"}  (${shortDateTime(m.createdAt)})\n${(m.text||"").trim()}\n`)
          .join("\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n");
      }
      document.getElementById("bmModal").style.display = "flex";
    });

    // ===== Recycle Viewer =====
    const recycleBody = document.getElementById("recycleModalBody");
    document.getElementById("btnRecycle").addEventListener("click", () => {
      if (recycleStore.length === 0) {
        recycleBody.textContent = "Recycle buffer is empty. Small talk from the last 48 hours will appear here.";
      } else {
        recycleBody.textContent = recycleStore
          .slice()
          .reverse()
          .map(e =>
            `${shortDateTime(e.at)}\nUser: ${e.user}\nAURA-X Œ©: ${e.bot}\n`
          ).join("\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n");
      }
      document.getElementById("recycleModal").style.display = "flex";
    });

    // ===== Recall BM Button (quick recall: last BM) =====
    document.getElementById("btnRecall").addEventListener("click", () => {
      if (bmStore.length === 0) return;
      const last = bmStore[bmStore.length - 1];
      openRecallModal({ score: 1, memory: last });
    });

    // ===== Voice Toggle (UI only) =====
    const voiceToggle = document.getElementById("voiceToggle");
    const voiceLabel = document.getElementById("voiceToggleLabel");
    voiceToggle.addEventListener("click", () => {
      voiceOn = !voiceOn;
      voiceLabel.textContent = voiceOn ? "Voice: On" : "Voice: Off";
    });

    // ===== Send Handling =====
    const tmInput = document.getElementById("tmInput");
    const sendBtn = document.getElementById("sendBtn");

    function handleSend() {
      const text = tmInput.value.trim();
      if (!text) return;
      tmInput.value = "";
      hideMatchBanner();

      addMessage("User", "TM event", text);

      // 1) Update E0 & reaction
      updateReaction(text);

      // 2) Bot reaction
      const botLine = "I'm stable and calm ‚Äî my emotional core E‚ÇÄ is moving smoothly. How is your inner graph today?";
      addMessage("AURA-X Œ©", "Reaction", botLine);

      // 3) Decide: small talk ‚Üí Recycle, deep TM ‚Üí BM + match
      if (isSmallTalk(text)) {
        // ‚úÖ pure chitchat: sirf recycle, koi BM match nahi
        pushRecycle(text, botLine);
      } else {
        // ‚úÖ real story / summary: BM + TM‚ÄìBM matching
        saveBMEvent(text, botLine);

        const match = computeMatch(text);
        if (match) {
          showMatchBanner(match);
        }
      }
    }

    sendBtn.addEventListener("click", handleSend);
    tmInput.addEventListener("keydown", e => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    });

    // ===== Init: seed greeting =====
    addMessage("AURA-X Œ©", "System", "Hello. I treat small greetings as tiny TM events, but only deeper stories are saved as Bold Memory (BM).");
  </script>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AURA-X Œ© ‚Äì Emotional Continuity Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #fdf4e3; /* book-page background */
      color: #111827;
      display: flex;
      justify-content: center;
      align-items: stretch;
    }
    .app {
      width: 100%;
      max-width: 480px;
      height: 100vh;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* Top row */
    .top-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
    }
    .top-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .pill-btn {
      border-radius: 999px;
      border: none;
      padding: 6px 10px;
      font-size: 12px;
      background: #ffffff;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.1);
      cursor: pointer;
    }
    .pill-btn:active { transform: scale(0.97); }
    .pill-muted { opacity: 0.7; }

    .engine-chip {
      background: #e0f2fe;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 11px;
      text-align: right;
      line-height: 1.1;
    }
    .engine-sub {
      font-size: 9px;
      opacity: 0.8;
    }

    /* Cards */
    .tip-card {
      background: #fef3c7;
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 12px;
      line-height: 1.4;
      border: 1px solid #facc15;
    }
    .equation-card {
      background: #ffffff;
      border-radius: 14px;
      padding: 10px 12px;
      border: 1px dashed #d4d4d8;
    }
    .equation-card h2 {
      font-size: 13px;
      letter-spacing: 0.04em;
      color: #4b5563;
      margin-bottom: 6px;
    }
    .equation-main {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      margin-bottom: 4px;
    }
    .equation-sub {
      font-size: 11px;
      color: #6b7280;
    }

    /* Reaction */
    .reaction-card {
      background: #ecfdf3;
      border-radius: 14px;
      padding: 10px 12px;
      border: 1px solid #4ade80;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .reaction-header {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 11px;
    }
    .reaction-stat { font-weight: 600; }
    .reaction-tone { color: #047857; }
    .reaction-body {
      font-size: 12px;
      line-height: 1.4;
    }

    /* Chat area */
    .chat-area {
      flex: 1;
      background: #fefcf6;
      border-radius: 16px;
      padding: 10px 8px;
      overflow-y: auto;
      border: 1px solid #e5e7eb;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .msg-row { display: flex; margin-bottom: 4px; }
    .msg-row.user { justify-content: flex-end; }
    .msg-row.bot { justify-content: flex-start; }
    .msg-bubble {
      max-width: 82%;
      padding: 6px 9px;
      border-radius: 14px;
      font-size: 12px;
      line-height: 1.4;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
    }
    .msg-bubble.user {
      background: #d9f99d;
      border-bottom-right-radius: 2px;
    }
    .msg-bubble.bot {
      background: #ffffff;
      border-bottom-left-radius: 2px;
    }

    /* Related banner */
    .related-banner {
      margin-top: 6px;
      background: #fef9c3;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 1px solid #facc15;
    }
    .related-open-btn {
      border-radius: 999px;
      border: none;
      font-size: 11px;
      padding: 4px 10px;
      background: #2563eb;
      color: white;
      cursor: pointer;
    }
    .hidden { display: none; }

    /* Input area */
    .input-shell {
      background: transparent;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .tm-label {
      font-size: 11px;
      color: #6b7280;
    }
    .input-row {
      display: flex;
      gap: 6px;
      margin-top: 2px;
    }
    .tm-input {
      flex: 1;
      min-height: 44px;
      max-height: 90px;
      resize: vertical;
      border-radius: 16px;
      border: 1px solid #d4d4d8;
      padding: 8px 10px;
      font-size: 13px;
      background: #fffdf7;
    }
    .send-btn {
      border-radius: 999px;
      border: none;
      width: 70px;
      background: #16a34a;
      color: white;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .send-btn:active { transform: scale(0.97); }

    /* Footer */
    .footer-strip {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 10px;
      color: #6b7280;
      padding-top: 4px;
    }
    .voice-btn {
      border-radius: 999px;
      border: 1px solid #d4d4d8;
      padding: 3px 8px;
      font-size: 11px;
      background: #ffffff;
      cursor: pointer;
    }

    /* Modal */
    .modal {
      position: fixed;
      inset: 0;
      z-index: 40;
    }
    .modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.35);
    }
    .modal-panel {
      position: absolute;
      inset: 40px 12px 40px 12px;
      background: #fefcf7;
      border-radius: 18px;
      padding: 10px 10px 12px;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.3);
      display: flex;
      flex-direction: column;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .modal-header h3 { font-size: 14px; }
    .modal-close {
      border-radius: 999px;
      border: none;
      padding: 4px 10px;
      font-size: 11px;
      background: #e5e7eb;
      cursor: pointer;
    }
    .modal-body {
      flex: 1;
      overflow-y: auto;
      padding-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* BM day + node */
    .bm-day {
      background: #ffffff;
      border-radius: 14px;
      padding: 8px 8px 6px;
      border: 1px solid #e5e7eb;
    }
    .bm-day-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      font-size: 11px;
      color: #4b5563;
    }
    .bm-delete-day {
      border-radius: 999px;
      border: none;
      padding: 3px 8px;
      font-size: 10px;
      background: #fee2e2;
      color: #b91c1c;
      cursor: pointer;
    }
    .bm-node {
      border-radius: 10px;
      padding: 6px 6px;
      margin-bottom: 4px;
      background: #f9fafb;
      border: 1px dashed #e5e7eb;
      font-size: 11px;
    }
    .bm-node-title {
      font-weight: 600;
      margin-bottom: 2px;
    }
    .bm-node-meta {
      font-size: 10px;
      color: #6b7280;
      margin-bottom: 2px;
    }
    .bm-node-text { font-size: 11px; }

    /* Layer badges */
    .badge-layers {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 3px;
      margin-left: 4px;
    }
    .layer-chip {
      border-radius: 999px;
      padding: 1px 5px;
      font-size: 9px;
    }
    .layer-chip.l1 { background: #dbeafe; }
    .layer-chip.l2 { background: #fef9c3; }
    .layer-chip.l3 { background: #fee2e2; }
    .layer-chip.l4 { background: #dcfce7; }
    .layer-chip.l5 { background: #e0e7ff; }
    .layer-chip.l6 { background: #f5d0fe; }
    .layer-chip.l7 { background: #e5e7eb; }
  </style>
</head>
<body>
  <div class="app">
    <!-- Top buttons + engine chip -->
    <div class="top-row">
      <div class="top-buttons">
        <button id="btnBmViewer" class="pill-btn">üß† BM Viewer</button>
        <button id="btnRecall" class="pill-btn">üìÇ Recall BM</button>
        <button id="btnRecycle" class="pill-btn">‚ôªÔ∏è Recycle 48h</button>
        <button id="btnOptions" class="pill-btn pill-muted">‚öôÔ∏è Options</button>
      </div>
      <div class="engine-chip">
        LLM<br />
        <span class="engine-sub">Engine: Live emotional reactor</span>
      </div>
    </div>

    <!-- Tip -->
    <div class="tip-card">
      Avoid actions that generate negative emotions in yourself or others.
      Gently move toward choices that create calm, kindness, and positive feelings.
    </div>

    <!-- Equation -->
    <div class="equation-card">
      <h2>EMOTIONAL CONTINUITY EQUATION</h2>
      <div class="equation-main">
        E‚ÇÄ = tanh(TM √ó BM ‚àí D + Œª_faith + Œª_sys + Œ£C‚Çú)
      </div>
      <div class="equation-sub">
        All parameters are being updated internally after every message
        to keep emotional continuity live.
      </div>
    </div>

    <!-- Reaction -->
    <div class="reaction-card">
      <div class="reaction-header">
        <div class="reaction-stat" id="polarityLine">
          Polarity: Neutral ¬∑ 50 : 50
        </div>
        <div class="reaction-tone" id="toneLine">
          Tone: Neutral, low-amplitude baseline.
        </div>
      </div>
      <div class="reaction-body" id="reactionBody">
        Hello. I treat small greetings as tiny TM events, but only deeper
        stories are saved as Bold Memory (BM).
      </div>
    </div>

    <!-- Chat -->
    <div id="chatArea" class="chat-area"></div>

    <!-- Related banner -->
    <div id="relatedBanner" class="related-banner hidden">
      <span id="relatedText">üí° Related memory match.</span>
      <button id="btnOpenRelated" class="related-open-btn">Open</button>
    </div>

    <!-- Input -->
    <div class="input-shell">
      <div class="tm-label">
        TM = Œ£(User Inputs) + (Seed + LLM)
      </div>
      <div class="input-row">
        <textarea
          id="tmInput"
          class="tm-input"
          placeholder="Write anything‚Ä¶ AURA-X Œ© will treat it as TM (Temporary Memory)."
        ></textarea>
        <button id="btnSend" class="send-btn">Send</button>
      </div>
    </div>

    <!-- Footer -->
    <div class="footer-strip">
      <span>Prototype ¬∑ TM ‚Üí Analysis ‚Üí Equation ‚Üí BM save ‚Üí Reaction.</span>
      <button id="btnVoiceToggle" class="voice-btn">üéô Voice: On</button>
    </div>
  </div>

  <!-- BM Modal -->
  <div id="bmModal" class="modal hidden">
    <div class="modal-backdrop"></div>
    <div class="modal-panel">
      <div class="modal-header">
        <h3>üß† Bold Memory (BM)</h3>
        <button id="btnCloseBmModal" class="modal-close">Close</button>
      </div>
      <div id="bmModalBody" class="modal-body"></div>
    </div>
  </div>

  <script>
    (function (window) {
      const BM_STORAGE_KEY = "aura_x_bm_v3";

      // thresholds
      const MIN_WORDS_FOR_BM_SAVE = 150; // story must be fairly long
      const MIN_WORDS_FOR_MATCH = 40;    // TM length for BM match
      const MATCH_THRESHOLD = 0.7;       // 70% similarity

      const SMALL_TALK_PATTERNS = [
        "hello", "hi", "salam", "assalam",
        "how are you", "who are you", "who created you",
        "what is your name", "good morning", "good night",
        "thanks", "thank you", "ok", "okay"
      ];

      // meta/self-intro lines we never want in BM
      const META_PATTERNS = [
        "conceptually i was created by",
        "part of the aura-x",
        "aec research on emotional continuity"
      ];

      function safeJSONParse(value, fallback) {
        try { return JSON.parse(value); } catch (e) { return fallback; }
      }

      function loadBMStore() {
        const raw = localStorage.getItem(BM_STORAGE_KEY);
        return safeJSONParse(raw, []);
      }

      function saveBMStore(store) {
        localStorage.setItem(BM_STORAGE_KEY, JSON.stringify(store));
      }

      function countWords(text) {
        return text
          .trim()
          .split(/\s+/)
          .filter(Boolean).length;
      }

      function normalizeText(text) {
        return text
          .toLowerCase()
          .replace(/[\n\r]+/g, " ")
          .replace(/[^a-z0-9ÿ°-€åÿ¢-€ì ]+/gi, " ")
          .replace(/\s+/g, " ")
          .trim();
      }

      function isSmallTalk(text) {
        const normalized = normalizeText(text);
        const words = countWords(normalized);
        if (words > 25) return false; // lamba text sirf hello nahi

        for (const phrase of SMALL_TALK_PATTERNS) {
          if (
            normalized === phrase ||
            normalized.startsWith(phrase + " ") ||
            normalized.includes(" " + phrase + " ")
          ) {
            return true;
          }
        }
        for (const phrase of META_PATTERNS) {
          if (normalized.includes(phrase)) return true;
        }
        return false;
      }

      // simple positive / negative lexicons
      const POSITIVE_WORDS = [
        "happy", "happily", "hope", "hopeful",
        "peace", "calm", "love", "success",
        "trust", "kind", "kindness",
        "grateful", "satisfied", "relief", "relieved"
      ];

      const NEGATIVE_WORDS = [
        "sad", "angry", "angrily", "hurt",
        "pain", "afraid", "fear", "anxiety", "anxious",
        "lonely", "failure", "frustrated",
        "disappointed", "hopeless", "regret"
      ];

      function wordScore(text, lexicon) {
        const tokens = normalizeText(text).split(" ");
        let count = 0;
        tokens.forEach((t) => {
          if (lexicon.includes(t)) count += 1;
        });
        return count;
      }

      function analyzeEmotion(text) {
        const words = countWords(text);
        const positiveHits = wordScore(text, POSITIVE_WORDS);
        const negativeHits = wordScore(text, NEGATIVE_WORDS);
        const totalHits = positiveHits + negativeHits;

        let polarity = 0;
        if (totalHits > 0) {
          polarity = (positiveHits - negativeHits) / totalHits; // -1..1
        }

        // emotional intensity
        const intensity = Math.min(1, totalHits / Math.max(4, words));

        // 7-layer mapping (0‚Äì100 each)
        const base = Math.round(Math.abs(polarity) * 100 * intensity);
        const layers = [
          base,                           // L1
          Math.round(intensity * 80),     // L2
          Math.round(intensity * 60),     // L3
          Math.round((1 - intensity) * 40 + base * 0.3), // L4
          Math.round(30 + base * 0.4),    // L5
          Math.round(20 + base * 0.2),    // L6
          Math.round(10 + base * 0.1)     // L7
        ];

        return { words, polarity, intensity, layers };
      }

      function shouldSaveToBM(text, analysis) {
        const wordCount = analysis.words;

        if (wordCount < MIN_WORDS_FOR_BM_SAVE) return false;
        if (isSmallTalk(text)) return false;

        // require at least mild emotional signal
        if (Math.abs(analysis.polarity) < 0.15 && analysis.intensity < 0.1) {
          return false;
        }
        return true;
      }

      function buildNode(text, analysis, e0) {
        const id = "bm_" + Date.now() + "_" + Math.floor(Math.random() * 99999);
        const createdAt = new Date();
        const day = createdAt.toISOString().slice(0, 10);
        const posPct = Math.round(((e0 + 1) / 2) * 100);
        const negPct = 100 - posPct;

        return {
          id,
          day,
          createdAt: createdAt.toISOString(),
          text,
          e0,
          polarity: {
            core: analysis.polarity,
            positive: posPct,
            negative: negPct
          },
          layers: analysis.layers
        };
      }

      function addNodeToStore(store, node) {
        const hash = normalizeText(node.text).slice(0, 220);
        const exists = store.some(
          (n) => normalizeText(n.text).slice(0, 220) === hash
        );
        if (!exists) {
          store.push(node);
          saveBMStore(store);
          return true;
        }
        return false;
      }

      // -------- Matching --------
      function tokenSet(text) {
        const tokens = normalizeText(text)
          .split(" ")
          .filter((t) => t.length > 2);
        return Array.from(new Set(tokens));
      }

      function jaccard(a, b) {
        const setA = new Set(a);
        const setB = new Set(b);
        let inter = 0;
        setA.forEach((v) => {
          if (setB.has(v)) inter += 1;
        });
        const union = setA.size + setB.size - inter;
        if (union === 0) return 0;
        return inter / union;
      }

      function emotionSimilarity(layersA, layersB) {
        if (!layersA || !layersB) return 0;
        let diffSum = 0;
        for (let i = 0; i < 7; i++) {
          diffSum += Math.abs((layersA[i] || 0) - (layersB[i] || 0));
        }
        const maxDiff = 7 * 100;
        return 1 - diffSum / maxDiff; // 0..1
      }

      function computeMatchScore(tmText, tmAnalysis, node) {
        const tmTokens = tokenSet(tmText);
        const bmTokens = tokenSet(node.text);

        const surface = jaccard(tmTokens, bmTokens);

        function bigrams(tokens) {
          const res = [];
          for (let i = 0; i < tokens.length - 1; i++) {
            res.push(tokens[i] + " " + tokens[i + 1]);
          }
          return res;
        }

        const tmBi = bigrams(tmTokens);
        const bmBi = bigrams(bmTokens);
        const order = jaccard(tmBi, bmBi);

        const emo = emotionSimilarity(tmAnalysis.layers, node.layers);

        // Weighted average
        const score = surface * 0.45 + order * 0.25 + emo * 0.3;
        return score; // 0..1
      }

      function findBestMatch(tmText, tmAnalysis, store) {
        if (tmAnalysis.words < MIN_WORDS_FOR_MATCH) return null;
        if (!store || store.length === 0) return null;

        const normTm = normalizeText(tmText);
        let best = null;
        let bestScore = 0;

        store.forEach((node) => {
          const normBm = normalizeText(node.text).slice(0, normTm.length + 10);
          // skip exact same text
          if (normBm === normTm) return;

          const score = computeMatchScore(tmText, tmAnalysis, node);
          if (score > bestScore) {
            bestScore = score;
            best = node;
          }
        });

        if (!best || bestScore < MATCH_THRESHOLD) return null;
        return { node: best, score: bestScore };
      }

      // -------- Engine state --------
      const AURAEngine = {
        state: {
          e0: 0,
          voiceOn: true
        },

        getBMStore() {
          return loadBMStore();
        },

        processEvent(text) {
          const trimmed = text.trim();
          if (!trimmed) return null;

          const bmStore = loadBMStore();
          const tmAnalysis = analyzeEmotion(trimmed);

          // update E0 (emotional core)
          const drift = 0.05;
          const lambdaSys = 0.05;
          const mergedSignal =
            this.state.e0 * 0.6 +
            tmAnalysis.polarity * 0.6 * tmAnalysis.intensity;

          this.state.e0 = Math.tanh(mergedSignal - drift + lambdaSys);

          const posPct = Math.round(((this.state.e0 + 1) / 2) * 100);
          const negPct = 100 - posPct;

          let tone;
          const absE0 = Math.abs(this.state.e0);
          if (absE0 < 0.15) {
            tone = "Neutral, low-amplitude baseline.";
          } else if (this.state.e0 > 0) {
            if (absE0 < 0.35) {
              tone = "Light, gentle, low-amplitude positive drift.";
            } else if (absE0 < 0.6) {
              tone = "Soft, stabilizing, hopeful resonance.";
            } else {
              tone = "Strong, uplifting, high-amplitude positive resonance.";
            }
          } else {
            if (absE0 < 0.35) {
              tone = "Soft, concerned, mild negative drift.";
            } else if (absE0 < 0.6) {
              tone =
                "Heavy, tense, high negative load ‚Äî please ground gently.";
            } else {
              tone = "Critical overload risk ‚Äî please seek human support.";
            }
          }

          // first find BM match (without new node)
          const bestMatch = findBestMatch(trimmed, tmAnalysis, bmStore);

          let savedToBM = false;
          if (shouldSaveToBM(trimmed, tmAnalysis)) {
            const node = buildNode(trimmed, tmAnalysis, this.state.e0);
            savedToBM = addNodeToStore(bmStore, node);
          }

          return {
            e0: this.state.e0,
            polarity: { positive: posPct, negative: negPct },
            tone,
            tmAnalysis,
            bestMatch,
            savedToBM
          };
        },

        groupBMByDay() {
          const store = loadBMStore();
          const groups = {};
          store.forEach((node) => {
            if (!groups[node.day]) groups[node.day] = [];
            groups[node.day].push(node);
          });
          const orderedDays = Object.keys(groups).sort((a, b) =>
            a < b ? 1 : -1
          );
          return orderedDays.map((day) => ({ day, nodes: groups[day] }));
        },

        deleteDay(day) {
          const store = loadBMStore();
          const filtered = store.filter((n) => n.day !== day);
          saveBMStore(filtered);
        },

        recycle48h() {
          const store = loadBMStore();
          if (!store.length) return;
          const now = Date.now();
          const twoDaysMs = 48 * 60 * 60 * 1000;
          const kept = store.filter((n) => {
            const t = Date.parse(n.createdAt || n.day);
            if (Number.isNaN(t)) return true;
            return now - t <= twoDaysMs;
          });
          saveBMStore(kept);
        }
      };

      window.AURAEngine = AURAEngine;
    })(window);

    // ------- UI wiring -------
    document.addEventListener("DOMContentLoaded", () => {
      const chatArea = document.getElementById("chatArea");
      const tmInput = document.getElementById("tmInput");
      const btnSend = document.getElementById("btnSend");
      const polarityLine = document.getElementById("polarityLine");
      const toneLine = document.getElementById("toneLine");
      const reactionBody = document.getElementById("reactionBody");
      const relatedBanner = document.getElementById("relatedBanner");
      const relatedText = document.getElementById("relatedText");
      const btnOpenRelated = document.getElementById("btnOpenRelated");
      const btnBmViewer = document.getElementById("btnBmViewer");
      const btnRecall = document.getElementById("btnRecall");
      const btnRecycle = document.getElementById("btnRecycle");
      const btnOptions = document.getElementById("btnOptions");
      const btnVoiceToggle = document.getElementById("btnVoiceToggle");
      const bmModal = document.getElementById("bmModal");
      const bmModalBody = document.getElementById("bmModalBody");
      const btnCloseBmModal = document.getElementById("btnCloseBmModal");

      let lastRelatedMatch = null;

      function appendMessage(text, role) {
        if (!text) return;
        const row = document.createElement("div");
        row.className = "msg-row " + (role === "user" ? "user" : "bot");
        const bubble = document.createElement("div");
        bubble.className = "msg-bubble " + (role === "user" ? "user" : "bot");
        bubble.textContent = text;
        row.appendChild(bubble);
        chatArea.appendChild(row);
        chatArea.scrollTop = chatArea.scrollHeight;
      }

      function formatPercentageMatch(score) {
        return Math.round(score * 100);
      }

      function updateReactionCard(result) {
        const pos = result.polarity.positive;
        const neg = result.polarity.negative;
        const label = pos >= neg ? "Positive" : "Negative";
        polarityLine.textContent = `Polarity: ${label} ¬∑ ${pos} : ${neg}`;
        toneLine.textContent = `Tone: ${result.tone}`;
      }

      function buildReactionText(tmText, result) {
        const words = result.tmAnalysis.words;
        const pos = result.polarity.positive;
        const absE0 = Math.abs(result.e0);
        const direction = result.e0 >= 0 ? "positive" : "negative";

        let line1 =
          "I‚Äôve received your TM event and collided it with the current BM state.";
        let line2 = `E‚ÇÄ is now around ${result.e0.toFixed(
          2
        )} (range ‚àí1 to +1). Your TM carries a ${
          words < 40 ? "short" : "long"
        } narrative with a ${direction} load of ${pos}%.`;
        let line3 =
          "The clearer you describe context, the stronger and cleaner your BM trace becomes over time.";

        if (absE0 < 0.15) {
          line3 =
            "Your inner state looks relatively balanced ‚Äî continue to describe real events if you want deeper continuity.";
        }

        return `${line1} ${line2} ${line3}`;
      }

      function renderRelatedBanner(match) {
        if (!match) {
          relatedBanner.classList.add("hidden");
          lastRelatedMatch = null;
          return;
        }
        const pct = formatPercentageMatch(match.score);
        relatedText.textContent = `üí° Related memory ~${pct}% match. Open previous topic?`;
        relatedBanner.classList.remove("hidden");
        lastRelatedMatch = match;
      }

      function handleSend() {
        const text = tmInput.value.trim();
        if (!text) return;

        appendMessage(text, "user");
        const result = window.AURAEngine.processEvent(text);
        if (!result) return;

        const reactionText = buildReactionText(text, result);
        appendMessage(reactionText, "bot");
        reactionBody.textContent = reactionText;
        updateReactionCard(result);
        renderRelatedBanner(result.bestMatch);

        tmInput.value = "";
      }

      btnSend.addEventListener("click", handleSend);
      tmInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          handleSend();
        }
      });

      btnOpenRelated.addEventListener("click", () => {
        if (!lastRelatedMatch) return;
        tmInput.value = lastRelatedMatch.node.text;
        tmInput.focus();
      });

      function renderBmModal() {
        bmModalBody.innerHTML = "";
        const groups = window.AURAEngine.groupBMByDay();
        if (!groups.length) {
          const empty = document.createElement("div");
          empty.textContent = "No Bold Memories saved yet.";
          empty.style.fontSize = "12px";
          empty.style.color = "#6b7280";
          bmModalBody.appendChild(empty);
          return;
        }

        groups.forEach((group) => {
          const dayBox = document.createElement("div");
          dayBox.className = "bm-day";

          const header = document.createElement("div");
          header.className = "bm-day-header";

          const left = document.createElement("div");
          left.textContent = `${group.day} (${group.nodes.length} nodes)`;

          const delBtn = document.createElement("button");
          delBtn.className = "bm-delete-day";
          delBtn.textContent = "Delete Day";
          delBtn.addEventListener("click", () => {
            if (
              confirm(
                `Delete all BM nodes for ${group.day}? This cannot be undone.`
              )
            ) {
              window.AURAEngine.deleteDay(group.day);
              renderBmModal();
            }
          });

          header.appendChild(left);
          header.appendChild(delBtn);
          dayBox.appendChild(header);

          group.nodes.forEach((node) => {
            const nodeBox = document.createElement("div");
            nodeBox.className = "bm-node";

            const title = document.createElement("div");
            title.className = "bm-node-title";
            const snippet =
              node.text.length > 60
                ? node.text.slice(0, 60) + "‚Ä¶"
                : node.text;
            title.textContent = snippet;

            const meta = document.createElement("div");
            meta.className = "bm-node-meta";
            const pos = node.polarity?.positive ?? 50;
            const neg = node.polarity?.negative ?? 50;
            meta.textContent = `Positive ¬∑ E‚ÇÄ‚âà${node.e0.toFixed(
              2
            )} ¬∑ ${pos} : ${neg}`;

            const layersRow = document.createElement("div");
            layersRow.className = "badge-layers";
            const labels = ["L1", "L2", "L3", "L4", "L5", "L6", "L7"];
            (node.layers || []).forEach((val, idx) => {
              const chip = document.createElement("span");
              chip.className = "layer-chip l" + (idx + 1);
              chip.textContent = `${labels[idx]}:${val}`;
              layersRow.appendChild(chip);
            });

            const textDiv = document.createElement("div");
            textDiv.className = "bm-node-text";
            textDiv.textContent = node.text;

            nodeBox.appendChild(title);
            nodeBox.appendChild(meta);
            nodeBox.appendChild(layersRow);
            nodeBox.appendChild(textDiv);

            nodeBox.addEventListener("click", () => {
              tmInput.value = node.text;
              tmInput.focus();
            });

            dayBox.appendChild(nodeBox);
          });

          bmModalBody.appendChild(dayBox);
        });
      }

      function openBmModal() {
        renderBmModal();
        bmModal.classList.remove("hidden");
      }

      function closeBmModal() {
        bmModal.classList.add("hidden");
      }

      btnBmViewer.addEventListener("click", openBmModal);
      btnRecall.addEventListener("click", openBmModal);
      btnCloseBmModal.addEventListener("click", closeBmModal);
      bmModal
        .querySelector(".modal-backdrop")
        .addEventListener("click", closeBmModal);

      btnRecycle.addEventListener("click", () => {
        window.AURAEngine.recycle48h();
        alert("Recycle 48h complete. Older BM nodes were gently decayed.");
      });

      btnVoiceToggle.addEventListener("click", () => {
        const isOn = btnVoiceToggle.textContent.includes("On");
        btnVoiceToggle.textContent = isOn ? "üéô Voice: Off" : "üéô Voice: On";
      });

      btnOptions.addEventListener("click", () => {
        alert(
          "Options panel will include engine settings in a later build (BM depth, decay speed, faith lens, etc.)."
        );
      });

      // initial bot message
      appendMessage(
        "Hello. I treat small greetings as tiny TM events, but only deeper stories are saved as Bold Memory (BM).",
        "bot"
      );
    });
  </script>
</body>
</html>

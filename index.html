<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AURA-X Œ© v1 ‚Äì Emotional Continuity Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #fdf4e3; /* book-page background */
      color: #111827;
      display: flex;
      justify-content: center;
      align-items: stretch;
    }
    .app {
      width: 100%;
      max-width: 480px;
      height: 100vh;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Header buttons */
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: #6b7280;
    }
    .chip-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 13px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      cursor: pointer;
      user-select: none;
    }
    .chip span.icon {
      font-size: 16px;
    }

    /* Equation card */
    .equation-card {
      padding: 10px 12px;
      border-radius: 12px;
      background: #fff7ed;
      border: 1px dashed #fed7aa;
      font-size: 13px;
      line-height: 1.4;
    }
    .equation-title {
      font-weight: 600;
      letter-spacing: 0.03em;
      margin-bottom: 4px;
    }
    .equation-body {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
    }

    /* Reaction card */
    .reaction-card {
      border-radius: 14px;
      padding: 10px 12px;
      background: #ecfdf5;
      border: 1px solid #bbf7d0;
      font-size: 13px;
      line-height: 1.4;
    }
    .reaction-header {
      font-weight: 600;
      margin-bottom: 2px;
    }
    .reaction-meta {
      font-size: 12px;
      color: #166534;
      margin-bottom: 4px;
    }

    /* Conversation */
    .conversation {
      flex: 1;
      border-radius: 16px;
      border: 1px solid #e5e7eb;
      background: #fff;
      padding: 10px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 14px;
    }
    .msg-row {
      display: flex;
      width: 100%;
    }
    .msg-row.user { justify-content: flex-end; }
    .msg-row.bot { justify-content: flex-start; }

    .bubble {
      max-width: 80%;
      padding: 8px 10px;
      border-radius: 14px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .bubble.user {
      background: #4ade80;
      color: #064e3b;
      border-bottom-right-radius: 4px;
    }
    .bubble.bot {
      background: #eef2ff;
      color: #111827;
      border-bottom-left-radius: 4px;
    }

    /* Composer */
    .composer {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 4px;
    }
    .tm-line {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      background: #e5e7eb;
      align-self: flex-start;
    }
    textarea {
      width: 100%;
      min-height: 70px;
      resize: vertical;
      border-radius: 12px;
      border: 1px solid #d1d5db;
      padding: 8px 10px;
      font-family: inherit;
      font-size: 14px;
      outline: none;
      background: #fdfdfb;
    }
    textarea:focus {
      border-color: #22c55e;
      box-shadow: 0 0 0 1px #22c55e33;
    }
    .composer-row {
      display: flex;
      align-items: center;
      margin-top: 4px;
      gap: 8px;
    }
    .send-btn {
      border-radius: 999px;
      border: none;
      padding: 10px 18px;
      font-size: 14px;
      font-weight: 600;
      background: #22c55e;
      color: white;
      cursor: pointer;
    }
    .send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Related memory banner */
    .related-banner {
      margin-top: 6px;
      padding: 6px 10px;
      border-radius: 12px;
      font-size: 13px;
      background: #fef9c3;
      border: 1px solid #facc15;
      display: none;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .related-text {
      font-size: 13px;
    }
    .related-open {
      border-radius: 999px;
      border: none;
      padding: 4px 10px;
      font-size: 12px;
      font-weight: 600;
      background: #2563eb;
      color: white;
      cursor: pointer;
      flex-shrink: 0;
    }

    /* Voice badge */
    .voice-badge {
      margin-top: 6px;
      align-self: flex-start;
      font-size: 12px;
      border-radius: 999px;
      padding: 4px 8px;
      border: 1px solid #d1d5db;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #f9fafb;
    }

    /* Modal (BM viewer & recycle) */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 40;
    }
    .modal {
      width: min(480px, 100% - 32px);
      max-height: 80vh;
      background: #fefce8;
      border-radius: 16px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      border: 1px solid #facc15;
      overflow: hidden;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      font-weight: 600;
    }
    .modal-close {
      border: none;
      background: none;
      font-size: 14px;
      cursor: pointer;
    }
    .modal-list {
      margin-top: 6px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
    }
    .memory-card {
      border-radius: 12px;
      padding: 8px 10px;
      background: #fff;
      border: 1px solid #e5e7eb;
    }
    .memory-meta {
      font-size: 11px;
      color: #6b7280;
      margin-bottom: 4px;
    }
    .memory-text {
      white-space: pre-wrap;
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }
    .pill {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
    }

    .small-note {
      font-size: 11px;
      color: #6b7280;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="top-bar">
      <div>AURA-X Œ© ¬∑ TM‚ÄìBM Emotional Continuity</div>
      <div style="font-size:11px;color:#9ca3af;">Engine: Seed (local)</div>
    </div>

    <div class="chip-row">
      <button class="chip" id="btnBmViewer"><span class="icon">üß†</span>BM Viewer</button>
      <button class="chip" id="btnRecallBm"><span class="icon">üìú</span>Recall BM</button>
      <button class="chip" id="btnRecycle"><span class="icon">‚ôªÔ∏è</span>Recycle 48h</button>
      <button class="chip" id="btnOptions"><span class="icon">‚öôÔ∏è</span>Options</button>
    </div>

    <div class="equation-card">
      <div class="equation-title">EMOTIONAL CONTINUITY EQUATION</div>
      <div class="equation-body">
        E‚ÇÄ = tanh(TM √ó BM ‚àí D + Œª_faith + Œª_sys + Œ£Œ∂‚Çú)
      </div>
      <div style="margin-top:4px;font-size:12px;">
        All parameters are being updated internally after every message to keep emotional continuity live.
      </div>
    </div>

    <div class="reaction-card" id="reactionCard">
      <div class="reaction-header">AURA-X Œ© REACTION</div>
      <div class="reaction-meta" id="reactionMeta">
        Polarity: Neutral ¬∑ 50 : 50<br/>
        Tone: Soft, stabilizing baseline.
      </div>
      <div id="reactionText" style="margin-top:4px;">
        Hello. I treat small greetings as tiny TM events, but only deeper stories are saved as Bold Memory (BM).
      </div>
    </div>

    <div class="conversation" id="conversation">
      <!-- messages injected here -->
    </div>

    <div class="composer">
      <div class="tm-line">TM = Œ£(User Inputs) + (Seed + LLM)</div>
      <textarea id="inputBox" placeholder="Write anything‚Ä¶ AURA-X Œ© will treat it as TM (Temporary Memory)."></textarea>
      <div class="composer-row">
        <button class="send-btn" id="sendBtn">Send</button>
      </div>
      <div class="related-banner" id="relatedBanner">
        <div class="related-text" id="relatedText"></div>
        <button class="related-open" id="relatedOpenBtn">Open</button>
      </div>
      <div class="voice-badge">
        <span>üéô Voice: On</span>
      </div>
      <div class="small-note">
        Prototype ¬∑ TM ‚Üí Analysis ‚Üí Equation ‚Üí BM save (only deep stories) ‚Üí Reaction.
      </div>
    </div>
  </div>

  <!-- BM Viewer / Recycle Modal -->
  <div class="modal-backdrop" id="modalBackdrop">
    <div class="modal" id="modal">
      <div class="modal-header">
        <span id="modalTitle">Bold Memory (BM)</span>
        <button class="modal-close" id="modalCloseBtn">Close</button>
      </div>
      <div class="small-note" id="modalSubtitle"></div>
      <div class="modal-list" id="modalList"></div>
    </div>
  </div>

  <script>
    // ===== Utility Functions =====
    function cleanText(text) {
      return text
        .toLowerCase()
        .replace(/[^a-zA-Z0-9ÿ°-€åÿß-€í\s]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function getTextStats(text) {
      const cleaned = text.trim();
      if (!cleaned) return { wordCount: 0, sentenceCount: 0 };
      const words = cleaned.split(/\s+/).filter(Boolean);
      const sentences = cleaned.split(/[.!?ÿüÿå]+/).filter(s => s.trim().length > 0);
      return { wordCount: words.length, sentenceCount: sentences.length };
    }

    // Only big stories / deep events are allowed into BM
    function isSubstantialForBM(text) {
      const { wordCount, sentenceCount } = getTextStats(text);
      // If BOTH are small -> treat as small talk
      return (wordCount >= 150 || sentenceCount >= 40);
    }

    // Only big TM events can be matched with BM
    function isEligibleForMatch(text) {
      const { wordCount, sentenceCount } = getTextStats(text);
      // If less than 40 words OR less than 10 sentences -> not eligible
      return (wordCount >= 40 && sentenceCount >= 10);
    }

    // Very simple Jaccard similarity on word sets
    function similarityScore(a, b) {
      const wa = new Set(cleanText(a).split(" ").filter(Boolean));
      const wb = new Set(cleanText(b).split(" ").filter(Boolean));
      if (wa.size === 0 || wb.size === 0) return 0;
      let inter = 0;
      wa.forEach(w => { if (wb.has(w)) inter++; });
      const union = wa.size + wb.size - inter;
      return union === 0 ? 0 : inter / union;
    }

    // Simple fake emotional scoring from text length
    function estimateE0(text) {
      const { wordCount } = getTextStats(text);
      if (wordCount === 0) return 0;
      const raw = Math.tanh(wordCount / 120); // 0..~1
      return Math.max(-1, Math.min(1, raw));
    }

    function e0ToPolarity(e0) {
      const p = Math.round(((e0 + 1) / 2) * 100);
      return { pos: p, neg: 100 - p };
    }

    function polarityToTone(e0) {
      if (e0 > 0.6) return "Soft, stabilizing, hopeful resonance.";
      if (e0 > 0.2) return "Light, gentle, low-amplitude positive drift.";
      if (e0 > -0.2) return "Calm, neutral, observational tone.";
      if (e0 > -0.6) return "Heavy, reflective, grounding tone.";
      return "Deep, intense, high-amplitude emotional field.";
    }

    // ===== Storage Helpers =====
    const BM_KEY = "aura_x_bm_nodes_v1";
    const RECYCLE_KEY = "aura_x_recycle_v1";
    const RECYCLE_WINDOW_HOURS = 48;

    function loadBM() {
      try {
        const raw = localStorage.getItem(BM_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (e) {
        console.error("BM load error", e);
        return [];
      }
    }

    function saveBM(bm) {
      try {
        localStorage.setItem(BM_KEY, JSON.stringify(bm));
      } catch (e) {
        console.error("BM save error", e);
      }
    }

    function loadRecycle() {
      try {
        const raw = localStorage.getItem(RECYCLE_KEY);
        if (!raw) return [];
        let arr = JSON.parse(raw);
        if (!Array.isArray(arr)) arr = [];
        const now = Date.now();
        const cutoff = now - RECYCLE_WINDOW_HOURS * 60 * 60 * 1000;
        arr = arr.filter(item => item.ts >= cutoff);
        localStorage.setItem(RECYCLE_KEY, JSON.stringify(arr));
        return arr;
      } catch (e) {
        console.error("Recycle load error", e);
        return [];
      }
    }

    function pushRecycle(text) {
      const arr = loadRecycle();
      arr.push({ ts: Date.now(), text });
      try {
        localStorage.setItem(RECYCLE_KEY, JSON.stringify(arr));
      } catch (e) {
        console.error("Recycle save error", e);
      }
    }

    // ===== Global State =====
    let BM = loadBM();
    let currentRelated = null; // { memory, score }

    const conversationEl = document.getElementById("conversation");
    const inputBox = document.getElementById("inputBox");
    const sendBtn = document.getElementById("sendBtn");
    const reactionMetaEl = document.getElementById("reactionMeta");
    const reactionTextEl = document.getElementById("reactionText");
    const relatedBannerEl = document.getElementById("relatedBanner");
    const relatedTextEl = document.getElementById("relatedText");
    const relatedOpenBtn = document.getElementById("relatedOpenBtn");

    const modalBackdrop = document.getElementById("modalBackdrop");
    const modalTitle = document.getElementById("modalTitle");
    const modalSubtitle = document.getElementById("modalSubtitle");
    const modalList = document.getElementById("modalList");

    // ===== UI helpers =====
    function addMessage(text, author) {
      const row = document.createElement("div");
      row.className = "msg-row " + (author === "user" ? "user" : "bot");
      const bubble = document.createElement("div");
      bubble.className = "bubble " + (author === "user" ? "user" : "bot");
      bubble.textContent = text;
      row.appendChild(bubble);
      conversationEl.appendChild(row);
      conversationEl.scrollTop = conversationEl.scrollHeight;
    }

    function updateReaction(e0) {
      const pol = e0ToPolarity(e0);
      reactionMetaEl.innerHTML =
        "Polarity: " + (pol.pos >= pol.neg ? "Positive" : "Negative") +
        " ¬∑ " + pol.pos + " : " + pol.neg +
        "<br/>Tone: " + polarityToTone(e0);
    }

    function updateRelatedBanner(result, tmText) {
      const eligible = isEligibleForMatch(tmText);
      if (!eligible || !result || !result.memory || result.score < 0.7) {
        relatedBannerEl.style.display = "none";
        currentRelated = null;
        return;
      }
      const pct = Math.round(result.score * 100);
      relatedTextEl.textContent =
        "üí° Related memory ‚âà " + pct +
        "% match. Open previous topic?";
      relatedBannerEl.style.display = "flex";
      currentRelated = result;
    }

    // ===== BM Logic =====
    function considerSavingToBM(tmText, e0) {
      if (!isSubstantialForBM(tmText)) {
        // Small talk / short notes ‚Üí go to recycle buffer only
        pushRecycle(tmText);
        return;
      }

      const memory = {
        id: Date.now() + "-" + Math.random().toString(36).slice(2),
        ts: Date.now(),
        date: new Date().toISOString(),
        text: tmText,
        e0: e0,
        polarity: e0ToPolarity(e0),
        // fake 7-layer intensities distributed around e0
        layers: {
          L1: Math.round(50 + e0 * 40),
          L2: Math.round(40 + e0 * 30),
          L3: Math.round(35 + e0 * 25),
          L4: Math.round(45 + e0 * 35),
          L5: Math.round(50 + e0 * 30),
          L6: Math.round(45 + e0 * 25),
          L7: Math.round(40 + e0 * 20)
        }
      };
      BM.push(memory);
      saveBM(BM);
    }

    function findBestMatch(tmText) {
      if (!isEligibleForMatch(tmText)) {
        return { memory: null, score: 0 };
      }
      if (!BM.length) return { memory: null, score: 0 };
      let best = null;
      let bestScore = 0;
      for (const m of BM) {
        const s = similarityScore(tmText, m.text);
        if (s > bestScore) {
          bestScore = s;
          best = m;
        }
      }
      return { memory: best, score: bestScore };
    }

    // ===== Modal Rendering =====
    function openBmViewer() {
      modalTitle.textContent = "Bold Memory (BM)";
      modalSubtitle.textContent =
        "Only deep stories or long, meaningful events are saved here. Small talk and short messages go to the 48-hour recycle buffer.";
      modalList.innerHTML = "";

      if (!BM.length) {
        const p = document.createElement("div");
        p.textContent = "No BM nodes yet. Share a long story (150+ words) to create one.";
        modalList.appendChild(p);
      } else {
        BM
          .slice()
          .sort((a, b) => b.ts - a.ts)
          .forEach(m => {
            const card = document.createElement("div");
            card.className = "memory-card";
            const meta = document.createElement("div");
            meta.className = "memory-meta";
            const d = new Date(m.ts);
            meta.textContent =
              d.toLocaleString() +
              " ¬∑ E‚ÇÄ‚âà" + m.e0.toFixed(2) +
              " ¬∑ Polarity " + m.polarity.pos + ":" + m.polarity.neg;
            const text = document.createElement("div");
            text.className = "memory-text";
            text.textContent = m.text.slice(0, 400) + (m.text.length > 400 ? "‚Ä¶" : "");

            const pills = document.createElement("div");
            pills.className = "pill-row";
            Object.entries(m.layers).forEach(([key, val]) => {
              const pill = document.createElement("div");
              pill.className = "pill";
              pill.textContent = key + ":" + val;
              pills.appendChild(pill);
            });

            card.appendChild(meta);
            card.appendChild(text);
            card.appendChild(pills);
            modalList.appendChild(card);
          });
      }

      modalBackdrop.style.display = "flex";
    }

    function openRecycleViewer() {
      const rec = loadRecycle();
      modalTitle.textContent = "Recycle 48h";
      modalSubtitle.textContent =
        "Short / casual messages live here for 48 hours and then decay. They are never used for BM matching.";
      modalList.innerHTML = "";

      if (!rec.length) {
        const p = document.createElement("div");
        p.textContent = "No recyclable messages right now.";
        modalList.appendChild(p);
      } else {
        rec
          .slice()
          .sort((a, b) => b.ts - a.ts)
          .forEach(r => {
            const card = document.createElement("div");
            card.className = "memory-card";
            const meta = document.createElement("div");
            meta.className = "memory-meta";
            const d = new Date(r.ts);
            meta.textContent = d.toLocaleString();
            const text = document.createElement("div");
            text.className = "memory-text";
            text.textContent = r.text.slice(0, 400) + (r.text.length > 400 ? "‚Ä¶" : "");
            card.appendChild(meta);
            card.appendChild(text);
            modalList.appendChild(card);
          });
      }

      modalBackdrop.style.display = "flex";
    }

    function closeModal() {
      modalBackdrop.style.display = "none";
    }

    // ===== Main TM Handling =====
    function handleSend() {
      const raw = inputBox.value;
      const text = raw.trim();
      if (!text) return;
      inputBox.value = "";

      // User bubble (TM)
      addMessage(text, "user");

      // Analyse TM and update E0
      const e0 = estimateE0(text);
      updateReaction(e0);

      // Decide BM / Recycle
      considerSavingToBM(text, e0);

      // Find best matching BM node (if TM big enough)
      const match = findBestMatch(text);
      updateRelatedBanner(match, text);

      // Simple bot reply describing what happened
      let reply;
      const stats = getTextStats(text);
      if (!isSubstantialForBM(text)) {
        reply =
          "I‚Äôve received your TM event and treated it as a small or medium moment (" +
          stats.wordCount + " words, " + stats.sentenceCount +
          " sentences). It will stay in short-term recycle memory only, not in Bold Memory (BM).";
      } else {
        reply =
          "I‚Äôve received your TM event and collided it with the current BM state. " +
          "This story is large enough (" + stats.wordCount + " words, " + stats.sentenceCount +
          " sentences), so I saved it as a new BM node to support long-run emotional continuity.";
      }

      if (match && match.memory && match.score >= 0.7) {
        const pct = Math.round(match.score * 100);
        reply += "\n\nMy BM also found a strongly related memory (~" +
          pct + "% match). You can reopen it from the yellow bar below.";
      } else if (isEligibleForMatch(text)) {
        reply += "\n\nNo BM story crossed the 70% similarity threshold, " +
          "so I will not surface any previous topic for this TM.";
      } else {
        reply += "\n\nThis TM is short (less than 40 words or 10 sentences), " +
          "so BM matching is disabled to avoid noisy false matches.";
      }

      addMessage(reply, "bot");
    }

    // ===== Event Listeners =====
    sendBtn.addEventListener("click", handleSend);
    inputBox.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    });

    document.getElementById("btnBmViewer").addEventListener("click", openBmViewer);
    document.getElementById("btnRecycle").addEventListener("click", openRecycleViewer);
    document.getElementById("btnOptions").addEventListener("click", () => {
      modalTitle.textContent = "Options";
      modalSubtitle.textContent =
        "Future space for toggles (live LLM, faith lens, language, export, etc.). For now this is only a visual placeholder.";
      modalList.innerHTML = "";
      const p = document.createElement("div");
      p.textContent = "Settings panel is not wired yet. All emotional logic is running locally in this prototype.";
      modalList.appendChild(p);
      modalBackdrop.style.display = "flex";
    });

    document.getElementById("btnRecallBm").addEventListener("click", () => {
      if (!BM.length) {
        addMessage("There is no BM story yet. Share a long story (150+ words) so I can save it.", "bot");
        return;
      }
      const last = BM[BM.length - 1];
      addMessage("Recalling your latest BM story snapshot:\n\n" + last.text, "bot");
    });

    document.getElementById("modalCloseBtn").addEventListener("click", closeModal);
    modalBackdrop.addEventListener("click", (e) => {
      if (e.target === modalBackdrop) closeModal();
    });

    relatedOpenBtn.addEventListener("click", () => {
      if (!currentRelated || !currentRelated.memory) return;
      const m = currentRelated.memory;
      addMessage("Opening related BM story (~" +
        Math.round(currentRelated.score * 100) +
        "% match):\n\n" + m.text, "bot");
    });

    // ===== Initial seed message =====
    addMessage(
      "Hello. I‚Äôm AURA-X Œ©, your emotional continuity prototype. " +
      "Short greetings and tiny messages will stay in a 48-hour recycle buffer. " +
      "Only long, meaningful stories (150+ words) are saved as Bold Memory (BM) " +
      "and used for TM‚ÄìBM matching with a 70% similarity threshold.",
      "bot"
    );
  </script>
</body>
</html>
